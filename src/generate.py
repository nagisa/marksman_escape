import html.entities
import itertools
import collections
import pprint
import io

# How many keys matched by memcmp is deemed more expensive than compiling an additional branch
BRANCH_FACTOR = 7

class Trie(object):
    def __init__(self, depth=0):
        self.depth = depth
        self.values_inside = 0
        self.value = None
        self.letters = collections.defaultdict(lambda: Trie(self.depth + 1))

    def add_word(self, word, value):
        if len(word) == 0:
            self.value = value
        else:
            letter = word[0]
            rest = word[1:]
            self.values_inside += 1
            self.letters[letter].add_word(rest, value)

    def build_matcher(self, f):
        if len(list(self.keys())) > BRANCH_FACTOR:
            f.write("""match name.get({}).cloned() {{\n""".format(self.depth))
            for l, trie in sorted(self.letters.items(), key=lambda x: x[0]):
                inner = io.StringIO()
                trie.build_matcher(inner)
                self.write(f, "Some(b'{}') => {},\n".format(l, inner.getvalue()))
            self.write(f, "None => {}, _ => None,\n".format(self.get_default_value()))
            self.write(f, "}", -1)
        else: # Donâ€™t generate too many branch, it hurts compile times hard
            f.write("""match &name[{}..] {{\n""".format(self.depth))
            for k, v in sorted(self.keys()):
                self.write(f, """{} => Some({}),\n""".format(self.str_to_rstr(k),
                                                             self.str_to_rstr(v)))
            self.write(f, "_ => None,\n")
            self.write(f, "}", -1)

    def keys(self):
        if self.value:
            yield ("", self.value)
        for k, t in self.letters.items():
            for ik, value in t.keys():
                yield (k+ik, value)

    def write(self, f, v, adj=0):
        f.write("  "*(self.depth+adj) + v)

    def get_default_value(self):
        if self.value is not None:
            return """Some({})""".format(self.str_to_rstr(self.value))
        else:
            return "None"

    def str_to_rstr(self, s):
        es = []
        ascii_only = all(map(lambda x: ord(x) < 0x80, s))
        if ascii_only:
            return "b\"{}\"".format(s.replace("\\", "\\\\").replace("\"", "\\\""))
        else:
            return '''b"{}"'''.format(''.join(map(lambda x: "\\x{:X}".format(x), bytes(s, "utf-8"))))


if __name__ == "__main__":
    with open("unescape_named.rs", "w") as f:
        f.writelines([
            "//! This file is autogenerated by generate.py, do not modify\n",
            "\n",
            "/// Get the unicode value of a named reference.\n",
            "pub fn get_named_ref(name: &[u8]) -> Option<&'static [u8]> {\n"
        ])

        entities = html.entities.html5.items()
        trie = Trie()
        for k, v in sorted(entities, key=lambda x: x[0]):
            trie.add_word(k, v)
        trie.build_matcher(f)
        f.write("\n}");

        # f.write("\n\n#[test]\nfn test_get_named_ref(){\n")
        # f.write("    use std::str;")
        # for k, v in sorted(entities, key=lambda x: x[0]):
        #     f.write("    str::from_utf8(get_named_ref(b\"{}\").unwrap()).unwrap();\n".format(k));
        #     f.write("    assert!(get_named_ref(b\"{}\").is_none());\n".format(k+" "));
        #     f.write("    assert!(get_named_ref(b\"{}\").is_none());\n".format(" "+k));
        # f.write("\n}")
